<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Video Cutout</title>
<style>
body {margin:0; font-family:Arial,sans-serif; background:#0d1117; color:#c9d1d9; display:flex; flex-direction:column; align-items:center; padding:1em;}
h1 {font-size:1.3em; margin-bottom:0.5em;}
video,canvas {width:100%; max-width:640px; border-radius:12px; background:black; margin-bottom:1em;}
#controls {display:flex; flex-wrap:wrap; gap:0.5em; justify-content:center;}
button,input[type=file]{background:#238636;color:white;border:none;padding:0.6em 1em;border-radius:8px;font-size:1em;cursor:pointer;}
button:disabled{background:#444c56;}
#status{font-size:0.9em;opacity:0.8; text-align:center;}
</style>
</head>
<body>

<h1>AI Background Cutout</h1>
<div id="controls">
  <input type="file" id="videoInput" accept="video/*">
  <button id="startBtn" disabled>Start</button>
  <button id="downloadBtn" disabled>Download</button>
</div>

<video id="video" playsinline controls></video>
<canvas id="canvas"></canvas>
<p id="status">Waiting for video...</p>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const input = document.getElementById('videoInput');
const startBtn = document.getElementById('startBtn');
const downloadBtn = document.getElementById('downloadBtn');
const status = document.getElementById('status');

let seg=null, mask=null;
let worker=null;
let processing=false;
let framesQueue = [];
let finalVideoURL=null;
let frameRate = 30; // will adjust based on video

// Initialize Segmentation
async function initSeg(){
  seg = new SelfieSegmentation({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`});
  seg.setOptions({modelSelection:1});
  seg.onResults(r => mask = r.segmentationMask);
  await seg.initialize();
}
initSeg();

// Video input
input.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  video.src = URL.createObjectURL(file);
  video.onloadeddata = () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    frameRate = video.frameRate || 30;
    startBtn.disabled = false;
    status.textContent = 'Ready to process.';
  };
});

// Start processing
startBtn.onclick = async () => {
  if(!seg){status.textContent='Model loading...'; return;}
  if(worker) worker.terminate();
  worker = new Worker('processor-worker.js');
  framesQueue = [];
  processing = true;
  finalVideoURL = null;
  startBtn.disabled = true;
  downloadBtn.disabled = true;
  status.textContent = 'Processing...';

  worker.onmessage = e => {
    const msg = e.data;
    if(msg.type === 'frame'){
      const bitmap = msg.bitmap;
      ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
      framesQueue.push(bitmap);
    } else if(msg.type === 'done'){
      processing = false;
      status.textContent = 'Processing done. Video ready to play/download.';
      createFinalVideo();
    }
  };

  video.play();
  processLoop();
};

// Process loop
async function processLoop(){
  if(!processing) return;
  if(video.paused || video.ended){
    worker.postMessage({type:'finish'});
    return;
  }

  const bitmap = await createImageBitmap(video);
  await seg.send({image: video});
  if(mask){
    worker.postMessage({type:'frame', bitmap: bitmap, mask: mask}, [bitmap]);
  }
  requestAnimationFrame(processLoop);
}

// Create final video
async function createFinalVideo(){
  if(framesQueue.length === 0) return;
  const stream = canvas.captureStream(frameRate);
  const recorder = new MediaRecorder(stream);
  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = e => {
    const blob = new Blob(chunks, {type:'video/webm'});
    finalVideoURL = URL.createObjectURL(blob);
    video.src = finalVideoURL;
    downloadBtn.disabled = false;
  };
  recorder.start();
  for(let i=0;i<framesQueue.length;i++){
    ctx.drawImage(framesQueue[i], 0, 0, canvas.width, canvas.height);
    await new Promise(r => setTimeout(r, 1000/frameRate));
  }
  recorder.stop();
}

// Download
downloadBtn.onclick = () => {
  if(!finalVideoURL) return;
  const a = document.createElement('a');
  a.href = finalVideoURL;
  a.download = 'segmented_video.webm';
  a.click();
};
</script>
</body>
</html>