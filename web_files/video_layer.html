<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Video Layer Studio â€” AI Background Processor</title>
<style>
  body {
    background: #0d1117;
    color: #c9d1d9;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1em;
  }
  h1 {
    color: #58a6ff;
    margin-bottom: 1em;
  }
  video, canvas {
    width: 100%;
    max-width: 720px;
    border-radius: 12px;
    display: block;
    margin-bottom: 1em;
  }
  #outputVideo {
    display: none;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 1em;
  }
  button, select {
    background: #238636;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    cursor: pointer;
    font-weight: bold;
  }
  button:hover { background: #2ea043; }
  #status { margin-top: 1em; color: #8b949e; font-size: 0.9rem; text-align: center; }
  #progressBar {
    width: 100%;
    max-width: 720px;
    height: 10px;
    background: #21262d;
    border-radius: 5px;
    margin: 0.5em 0 1em;
    overflow: hidden;
  }
  #progressFill {
    height: 100%;
    width: 0%;
    background: #58a6ff;
    transition: width 0.2s linear;
  }
</style>
</head>
<body>

<h1>ðŸŽ¥ Video Layer Studio</h1>

<input type="file" id="videoInput" accept="video/*">

<video id="inputVideo" playsinline controls></video>
<canvas id="canvas"></canvas>
<video id="outputVideo" playsinline controls></video>

<div class="controls">
  <select id="effectSelect">
    <option value="person">Keep Foreground Only</option>
    <option value="blur">Blur Background</option>
    <option value="color">Replace Background Color</option>
    <option value="transparent">Transparent Background</option>
  </select>
  <button id="processBtn" disabled>Process</button>
  <button id="saveBtn" disabled>Save</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="progressBar"><div id="progressFill"></div></div>
<div id="status">Select a video to start.</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>
<script>
const inputVideo = document.getElementById('inputVideo');
const outputVideo = document.getElementById('outputVideo');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const input = document.getElementById('videoInput');
const processBtn = document.getElementById('processBtn');
const saveBtn = document.getElementById('saveBtn');
const resetBtn = document.getElementById('resetBtn');
const effectSelect = document.getElementById('effectSelect');
const progressBar = document.getElementById('progressFill');
const status = document.getElementById('status');

let seg, mask = null, frames = [], isProcessing = false;

// --- Load video ---
input.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  inputVideo.src = URL.createObjectURL(file);
  inputVideo.load();
  inputVideo.onloadeddata = () => {
    canvas.width = inputVideo.videoWidth;
    canvas.height = inputVideo.videoHeight;
    processBtn.disabled = false;
    saveBtn.disabled = true;
    outputVideo.style.display = 'none';
    canvas.style.display = 'block';
    status.textContent = `Loaded video (${inputVideo.videoWidth}x${inputVideo.videoHeight}).`;
  };
});

// --- Initialize MediaPipe ---
seg = new SelfieSegmentation({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`
});
seg.setOptions({ modelSelection: 1 });
seg.onResults(results => { mask = results.segmentationMask; });

// --- Apply effect ---
function applyEffect() {
  if (!mask) return;
  const effect = effectSelect.value;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (effect === 'person' || effect === 'transparent') {
    ctx.drawImage(inputVideo, 0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(mask, 0, 0, canvas.width, canvas.height);
  } else if (effect === 'blur') {
    const blurCanvas = document.createElement('canvas');
    blurCanvas.width = canvas.width;
    blurCanvas.height = canvas.height;
    const bctx = blurCanvas.getContext('2d');
    bctx.filter = 'blur(12px)';
    bctx.drawImage(inputVideo, 0, 0, canvas.width, canvas.height);

    ctx.drawImage(blurCanvas, 0, 0);
    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(mask, 0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'destination-over';
    ctx.drawImage(blurCanvas, 0, 0);
  } else if (effect === 'color') {
    ctx.fillStyle = '#004466';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(mask, 0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'destination-over';
    ctx.drawImage(inputVideo, 0, 0, canvas.width, canvas.height);
  }
  ctx.globalCompositeOperation = 'source-over';
}

// --- Process video ---
processBtn.onclick = async () => {
  if (isProcessing) return;
  isProcessing = true;
  processBtn.disabled = true;
  saveBtn.disabled = true;
  frames = [];
  progressBar.style.width = '0%';
  status.textContent = 'Processing frames...';

  const fps = 25;
  const totalFrames = Math.floor(inputVideo.duration * fps);

  for (let i = 0; i < totalFrames; i++) {
    await new Promise(r => {
      inputVideo.onseeked = r;
      inputVideo.currentTime = i / fps;
    });

    await seg.send({ image: inputVideo });
    applyEffect();

    frames.push(canvas.toDataURL('image/png'));
    progressBar.style.width = ((i / totalFrames) * 100).toFixed(1) + '%';
  }

  status.textContent = 'Encoding with FFmpeg.js...';
  await encodeVideo(frames, fps);
  isProcessing = false;
  processBtn.disabled = false;
};

// --- Encode video with FFmpeg.js ---
async function encodeVideo(frames, fps) {
  const { createFFmpeg, fetchFile } = FFmpeg;
  const ffmpeg = createFFmpeg({ log: false });
  await ffmpeg.load();

  for (let i = 0; i < frames.length; i++) {
    const img = await fetch(frames[i]).then(r => r.arrayBuffer());
    ffmpeg.FS('writeFile', `frame${String(i).padStart(5, '0')}.png`, new Uint8Array(img));
  }

  await ffmpeg.run('-framerate', String(fps), '-i', 'frame%05d.png', '-pix_fmt', 'yuv420p', 'output.mp4');
  const data = ffmpeg.FS('readFile', 'output.mp4');

  const blob = new Blob([data.buffer], { type: 'video/mp4' });
  const url = URL.createObjectURL(blob);

  outputVideo.src = url;
  outputVideo.style.display = 'block';
  canvas.style.display = 'none';
  outputVideo.play();

  saveBtn.disabled = false;
  saveBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url;
    a.download = 'processed_video.mp4';
    a.click();
  };

  status.textContent = 'Processing complete.';
  progressBar.style.width = '100%';
}

// --- Reset ---
resetBtn.onclick = () => {
  inputVideo.pause();
  inputVideo.src = '';
  outputVideo.src = '';
  mask = null;
  frames = [];
  progressBar.style.width = '0%';
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  status.textContent = 'Select a video to start.';
  processBtn.disabled = true;
  saveBtn.disabled = true;
};
</script>

</body>
</html>
