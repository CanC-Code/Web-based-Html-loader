<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Video Layer — AI Editor</title>
<link rel="stylesheet" href="style.css">
<style>
:root {
  --bg:#0d1117; --panel:#0f1720; --muted:#8b949e;
  --accent:#58a6ff; --btn:#238636;
}
html, body {
  height:100%; margin:0; padding:0;
  background:var(--bg); color:#c9d1d9;
  font-family:Inter, system-ui, sans-serif;
  display:flex; flex-direction:column; align-items:center;
  padding:12px; box-sizing:border-box;
}
header { text-align:center; margin-bottom:8px; }
h1 { margin:0; color:var(--accent); font-size:1.1rem; }
p.lead { margin:4px 0 0 0; color:var(--muted); }
main { width:100%; max-width:900px; display:flex; flex-direction:column; gap:12px; }
.mediaBox { background:#07080a; border:1px solid #16181c; border-radius:12px; padding:10px; }
.mediaInner { display:flex; flex-direction:column; align-items:center; gap:10px; }
video, canvas { width:100%; max-width:840px; border-radius:10px; background:#000; }

.controls {
  display:flex; flex-wrap:wrap; gap:8px; justify-content:center;
  background:#0b0d10; border-radius:10px; border:1px solid #111317; padding:10px;
}
button, select, input[type=file] {
  background:var(--btn); color:#fff; border:none;
  border-radius:8px; padding:10px; font-weight:600; cursor:pointer;
}
button:disabled { opacity:0.6; cursor:not-allowed; }
.aux { background:#111315; color:var(--muted); }

.progressWrap { width:100%; margin-top:8px; }
.progress { width:100%; height:8px; background:#0b0b0b; border:1px solid #151619; border-radius:6px; overflow:hidden; }
.progress > div { height:100%; width:0%; background:linear-gradient(90deg,#3bd,#58a6ff); transition:width .1s linear; }

#status { text-align:center; margin-top:6px; font-size:.9rem; color:var(--muted); }

@media(max-width:640px){
  button, select { width:100%; font-size:.95rem; }
}
</style>
</head>
<body>

<header>
  <h1>Video Layer — AI Editor</h1>
  <p class="lead">Load video → choose mode → process → replay → download.</p>
</header>

<main>
  <section class="mediaBox">
    <div class="mediaInner">
      <label style="width:100%; text-align:center;">
        <input id="videoInput" type="file" accept="video/*" />
      </label>

      <video id="inputVideo" playsinline controls></video>
      <canvas id="outputCanvas" aria-label="Processed output"></canvas>
    </div>
  </section>

  <section class="controls">
    <button id="startBtn">Start Processing</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="replayBtn" disabled>Replay</button>
    <button id="saveBtn" disabled>Download</button>

    <select id="modeSelect" class="aux">
      <option value="remove">Background Removal</option>
      <option value="blur">Background Blur</option>
      <option value="none">No Effect</option>
    </select>
  </section>

  <div class="progressWrap">
    <div class="progress"><div id="progressFill"></div></div>
  </div>

  <div id="status">Ready.</div>
</main>

<script src="detector.js"></script>
<script>
const videoInput = document.getElementById('videoInput');
const inputVideo = document.getElementById('inputVideo');
const outCanvas = document.getElementById('outputCanvas');
const outCtx = outCanvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const replayBtn = document.getElementById('replayBtn');
const saveBtn = document.getElementById('saveBtn');
const modeSelect = document.getElementById('modeSelect');

const progressFill = document.getElementById('progressFill');
const statusEl = document.getElementById('status');

let processing = false;
let pendingProcess = null;
let recorder = null;
let recordedBlobs = [];
let processedFrames = [];

// helpers
function setStatus(s){ statusEl.textContent = s; console.log('[video_layer]', s); }
function setProgress(p){ progressFill.style.width = `${Math.max(0, Math.min(100,p))}%`; }

// --- video load ---
videoInput.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  inputVideo.src = URL.createObjectURL(f);
  inputVideo.load();
  inputVideo.onloadeddata = () => {
    outCanvas.width = inputVideo.videoWidth;
    outCanvas.height = inputVideo.videoHeight;
    processedFrames = [];
    setStatus(`Loaded: ${inputVideo.videoWidth}×${inputVideo.videoHeight}`);
    setProgress(0);
    startBtn.disabled = false;
    stopBtn.disabled = true;
    saveBtn.disabled = true;
    replayBtn.disabled = true;
  };
});

// --- start processing ---
startBtn.addEventListener('click', async ()=>{
  if(!inputVideo.src){ setStatus('Choose a video first.'); return; }
  startBtn.disabled = true;
  stopBtn.disabled = false;
  replayBtn.disabled = true;
  saveBtn.disabled = true;
  modeSelect.disabled = true;

  setStatus('Initializing Detector...');
  try{
    await Detector.init({mode:modeSelect.value});
  }catch(err){
    console.error(err);
    setStatus('Detector init failed: '+err.message);
    startBtn.disabled = false;
    stopBtn.disabled = true;
    modeSelect.disabled = false;
    return;
  }

  recordedBlobs = [];
  processedFrames = [];
  const stream = outCanvas.captureStream(25);
  recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp8'});
  recorder.ondataavailable = ev=>{ if(ev.data && ev.data.size) recordedBlobs.push(ev.data); };
  recorder.onstop = ()=>{ setStatus('Recording stopped — ready to download.'); };

  processing = true;
  inputVideo.currentTime = 0;
  await inputVideo.play().catch(()=>{});

  setStatus('Processing...');
  processLoop();
});

// --- stop processing ---
stopBtn.addEventListener('click', ()=>{
  processing = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  modeSelect.disabled = false;
  replayBtn.disabled = recordedFrames.length>0;
  if(recorder && recorder.state==='recording') recorder.stop();
  setStatus('Processing stopped.');
});

// --- replay ---
replayBtn.addEventListener('click', ()=>{
  if(processedFrames.length===0) return;
  let idx=0;
  function frameLoop(){
    if(idx>=processedFrames.length) return;
    outCtx.putImageData(processedFrames[idx],0,0);
    idx++;
    requestAnimationFrame(frameLoop);
  }
  frameLoop();
});

// --- download ---
saveBtn.addEventListener('click', ()=>{
  if(recordedBlobs.length===0){ setStatus('Nothing recorded.'); return; }
  const blob = new Blob(recordedBlobs,{type:'video/webm'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `processed_${Date.now()}.webm`; a.click();
  setStatus('Downloaded processed video.');
});

// --- throttled processing loop ---
let lastTimestamp = 0;
const targetMs = 100; // ~10 fps safe

async function processLoop(timestamp){
  if(!processing) return;

  outCtx.drawImage(inputVideo,0,0,outCanvas.width,outCanvas.height);
  const frame = outCtx.getImageData(0,0,outCanvas.width,outCanvas.height);

  if(performance.now()-lastTimestamp>=targetMs && !pendingProcess){
    lastTimestamp = performance.now();
    pendingProcess = Detector.processFrame(frame,{mode:modeSelect.value})
      .then(mask=>{
        pendingProcess = null;
        if(mask){
          Detector.applyMask(outCtx, mask);
          processedFrames.push(outCtx.getImageData(0,0,outCanvas.width,outCanvas.height));
        }
      }).catch(err=>{
        console.error('Frame processing error:',err);
        pendingProcess=null;
      });
  }

  if(inputVideo.duration && !isNaN(inputVideo.duration)){
    setProgress((inputVideo.currentTime/inputVideo.duration)*100);
  }

  if(inputVideo.currentTime>=inputVideo.duration){
    processing=false;
    startBtn.disabled=false;
    stopBtn.disabled=true;
    modeSelect.disabled=false;
    saveBtn.disabled=recordedBlobs.length>0;
    replayBtn.disabled=processedFrames.length>0;
    setStatus('Processing finished.');
    if(recorder && recorder.state==='recording') recorder.stop();
    return;
  }

  requestAnimationFrame(processLoop);
}

window.addEventListener('beforeunload', e=>{
  if(processing){ e.preventDefault(); e.returnValue=''; }
});
</script>
</body>
</html>