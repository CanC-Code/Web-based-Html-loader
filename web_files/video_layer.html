<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Video Layer — Smart Background Remover</title>
<link rel="stylesheet" href="style.css">
<style>
  :root {
    --bg:#0d1117; --panel:#0f1720; --muted:#8b949e; --accent:#58a6ff; --btn:#238636;
  }
  html, body { height:100%; margin:0; }
  body {
    background:var(--bg);
    color:#c9d1d9;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:12px;
    box-sizing:border-box;
  }

  header { width:100%; max-width:920px; margin-bottom:8px; text-align:center;}
  h1 { margin:0; color:var(--accent); font-size:1.1rem; }
  p.lead { margin:6px 0 0 0; color:var(--muted); font-size:0.95rem; }

  main { width:100%; max-width:920px; display:flex; flex-direction:column; gap:12px; align-items:stretch; }

  .mediaBox {
    background:#07080a; border:1px solid #16181c;
    border-radius:12px; padding:10px; box-sizing:border-box;
  }
  .mediaInner { display:flex; flex-direction:column; gap:10px; align-items:center; }

  video, canvas {
    width:100%; max-width:820px; border-radius:10px;
    background:#000; display:block;
  }

  .controls {
    display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
    padding:10px; border-radius:10px;
    background:linear-gradient(180deg,#0b0d10,#071013);
    border:1px solid #111317;
  }
  .controls > * { min-width:120px; flex:1 1 auto; }

  button, select, input[type="file"] {
    appearance:none; -webkit-appearance:none;
    background:var(--btn); color:#fff;
    border:none; padding:10px 12px;
    border-radius:8px; font-weight:700;
    cursor:pointer; font-size:1rem;
  }
  button:disabled { background:#2f3338; opacity:0.7; cursor:not-allowed; }
  .aux { background:#111315; color:var(--muted); font-weight:600; }

  .progressWrap { width:100%; margin-top:8px; }
  .progress {
    width:100%; height:8px; background:#0b0b0b;
    border-radius:6px; overflow:hidden;
    border:1px solid #151619;
  }
  .progress > div {
    height:100%; width:0%; background:linear-gradient(90deg,#3bd, #58a6ff);
    transition:width 0.12s linear;
  }

  #status {
    margin-top:10px; color:var(--muted);
    font-size:0.95rem; text-align:center;
    word-break:break-word;
  }

  @media(max-width:640px){
    .controls { gap:6px; }
    button, select, input[type="file"] {
      font-size:0.95rem; padding:10px; min-width:unset; width:100%;
    }
  }
</style>
</head>
<body>
<header>
  <h1>Video Layer — Smart Background Remover</h1>
  <p class="lead">Load a video, press Start, and it’ll automatically stop when finished. Save your result after processing.</p>
</header>

<main>
  <section class="mediaBox">
    <div class="mediaInner">
      <label style="width:100%; text-align:center;">
        <input id="videoInput" type="file" accept="video/*"
          style="width:100%; padding:8px; border-radius:8px;" />
      </label>

      <video id="inputVideo" playsinline controls></video>
      <canvas id="outputCanvas" aria-label="Processed output"></canvas>
    </div>
  </section>

  <section class="controls" role="region" aria-label="Processing controls">
    <button id="startBtn">Start Processing</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="saveBtn" disabled>Save Video</button>
    <select id="modeSelect" class="aux" title="Processing mode">
      <option value="human" selected>Remove Background (People)</option>
      <option value="motion">Motion Focus</option>
      <option value="all">All Objects</option>
    </select>
  </section>

  <div class="progressWrap">
    <div class="progress"><div id="progressFill"></div></div>
  </div>

  <div id="status">Ready.</div>
</main>

<script src="detector.js"></script>
<script>
const inputVideo = document.getElementById('inputVideo');
const videoInput = document.getElementById('videoInput');
const outCanvas = document.getElementById('outputCanvas');
const outCtx = outCanvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const saveBtn = document.getElementById('saveBtn');
const modeSelect = document.getElementById('modeSelect');
const progressFill = document.getElementById('progressFill');
const statusEl = document.getElementById('status');

let processing = false;
let recorder = null;
let recordedBlobs = [];

function setStatus(msg){ statusEl.textContent = msg; console.log('[video_layer]', msg); }
function setProgress(p){ progressFill.style.width = `${Math.max(0,Math.min(100,p))}%`; }

videoInput.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  inputVideo.src = URL.createObjectURL(f);
  inputVideo.load();
  inputVideo.onloadeddata = ()=>{
    outCanvas.width = inputVideo.videoWidth;
    outCanvas.height = inputVideo.videoHeight;
    setStatus(`Loaded video: ${inputVideo.videoWidth}×${inputVideo.videoHeight}`);
    startBtn.disabled = false;
    stopBtn.disabled = true;
    saveBtn.disabled = true;
  };
});

startBtn.addEventListener('click', async ()=>{
  if(!inputVideo.src) return setStatus('Please load a video first.');
  if(typeof Detector === 'undefined') return setStatus('Detector not found.');
  try {
    await Detector.init({ mode: modeSelect.value });
  } catch(e){
    setStatus('Detector init failed: ' + e.message);
    return;
  }

  startBtn.disabled = true;
  stopBtn.disabled = false;
  modeSelect.disabled = true;
  saveBtn.disabled = true;
  recordedBlobs = [];
  setStatus('Starting processing...');

  try {
    const stream = outCanvas.captureStream(25);
    recorder = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp8' });
    recorder.ondataavailable = ev => { if(ev.data.size>0) recordedBlobs.push(ev.data); };
    recorder.onstop = ()=> setStatus('Recording stopped. Ready to save.');
    recorder.start(500);
  } catch(e){ console.warn('Recording unavailable:', e); }

  processing = true;
  inputVideo.currentTime = 0;
  await inputVideo.play().catch(()=>{});
  processLoop();
});

stopBtn.addEventListener('click', stopProcessing);

function stopProcessing(){
  if(!processing) return;
  processing = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  modeSelect.disabled = false;
  if(recorder && recorder.state === 'recording') recorder.stop();
  saveBtn.disabled = recordedBlobs.length === 0;
  setStatus('Processing stopped.');
}

saveBtn.addEventListener('click', ()=>{
  if(recordedBlobs.length===0) return setStatus('Nothing recorded.');
  const blob = new Blob(recordedBlobs, { type:'video/webm' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'processed_' + Date.now() + '.webm';
  a.click();
  setStatus('Saved processed video.');
});

async function processLoop(){
  if(!processing) return;
  outCtx.drawImage(inputVideo, 0,0,outCanvas.width,outCanvas.height);
  try {
    const frame = outCtx.getImageData(0,0,outCanvas.width,outCanvas.height);
    const mask = await Detector.processFrame(frame, { mode: modeSelect.value });
    if(mask) await Detector.applyMask(outCtx, mask);
  } catch(e){ console.warn('Frame process error:', e); }

  // update progress
  if(inputVideo.duration > 0)
    setProgress((inputVideo.currentTime / inputVideo.duration) * 100);

  // auto-stop when done
  if(inputVideo.ended || inputVideo.currentTime >= inputVideo.duration){
    stopProcessing();
    return;
  }

  requestAnimationFrame(processLoop);
}

window.addEventListener('beforeunload', (e)=>{
  if(processing){ e.preventDefault(); e.returnValue=''; }
});

setStatus('Ready.');
</script>
</body>
</html>