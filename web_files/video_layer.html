<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Video Layer — AI Processor</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<header>
  <h1>Video Layer — AI Background Processor</h1>
  <p class="lead">Load a video, select an effect, process, review, and download.</p>
</header>

<main>
  <section class="mediaBox">
    <div class="mediaInner">
      <label style="width:100%;">
        <input id="videoInput" type="file" accept="video/*" />
      </label>

      <video id="inputVideo" playsinline controls></video>
      <canvas id="outputCanvas"></canvas>
    </div>
  </section>

  <section class="controls">
    <select id="effectMode" class="aux">
      <option value="remove">Background Removal</option>
      <option value="blur">Background Blur</option>
    </select>
    <button id="processBtn">Process</button>
    <button id="playBtn" disabled>Play Processed</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="downloadBtn" disabled>Download</button>
  </section>

  <div class="progressWrap">
    <div class="progress"><div id="progressFill"></div></div>
  </div>

  <div id="status">Ready.</div>
</main>

<script src="detector.js"></script>
<script>
const videoInput = document.getElementById('videoInput');
const inputVideo = document.getElementById('inputVideo');
const outCanvas = document.getElementById('outputCanvas');
const outCtx = outCanvas.getContext('2d');

const effectMode = document.getElementById('effectMode');
const processBtn = document.getElementById('processBtn');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const downloadBtn = document.getElementById('downloadBtn');

const progressFill = document.getElementById('progressFill');
const statusEl = document.getElementById('status');

let worker = null;
let processing = false;
let frameQueue = [];
let recordedBlobs = [];
let recorder = null;

// --- Video load ---
videoInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  inputVideo.src = URL.createObjectURL(file);
  inputVideo.load();
  inputVideo.onloadeddata = () => {
    outCanvas.width = inputVideo.videoWidth;
    outCanvas.height = inputVideo.videoHeight;
    setStatus(`Loaded video: ${inputVideo.videoWidth}×${inputVideo.videoHeight}`);
  };
});

// --- UI helpers ---
function setStatus(s){ statusEl.textContent = s; }
function setProgress(p){ progressFill.style.width = `${Math.max(0, Math.min(100, p))}%`; }

// --- Process button ---
processBtn.addEventListener('click', () => {
  if (!inputVideo.src) return setStatus('Please load a video first.');
  startProcessing();
});

// --- Play/Pause ---
playBtn.addEventListener('click', () => {
  if (recorderBlobsURL) {
    processedVideo.src = recorderBlobsURL;
    processedVideo.play();
  }
});
pauseBtn.addEventListener('click', () => {
  if (processedVideo) processedVideo.pause();
});

// --- Download ---
downloadBtn.addEventListener('click', () => {
  if (recordedBlobs.length === 0) return;
  const blob = new Blob(recordedBlobs, { type: 'video/webm' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `processed_${Date.now()}.webm`;
  a.click();
});

// --- Processing ---
function startProcessing() {
  processBtn.disabled = true;
  setStatus('Initializing worker...');
  
  worker = new Worker('detector-worker.js');
  worker.postMessage({ type: 'init' });
  
  worker.onmessage = e => {
    const msg = e.data;
    if (msg.type === 'log') setStatus(msg.msg);
    else if (msg.type === 'mask') drawFrame(msg);
    else if (msg.type === 'done') finishProcessing();
  };

  recordedBlobs = [];
  const stream = outCanvas.captureStream(25);
  recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
  recorder.ondataavailable = ev => { if (ev.data && ev.data.size) recordedBlobs.push(ev.data); };
  recorder.start();

  processing = true;
  inputVideo.currentTime = 0;
  inputVideo.play().catch(()=>{});
  requestAnimationFrame(processLoop);
}

function processLoop() {
  if (!processing) return;

  if (!inputVideo.paused && !inputVideo.ended) {
    outCtx.drawImage(inputVideo, 0, 0, outCanvas.width, outCanvas.height);
    const frame = outCtx.getImageData(0, 0, outCanvas.width, outCanvas.height);
    worker.postMessage({ type: 'process', frame, mode: effectMode.value });
  }

  if (inputVideo.ended) {
    processing = false;
    worker.postMessage({ type: 'finish' });
  } else {
    requestAnimationFrame(processLoop);
  }
}

function drawFrame({ maskData, width, height }) {
  const imgData = new ImageData(new Uint8ClampedArray(maskData), width, height);
  // smooth edges
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = width;
  tempCanvas.height = height;
  const tCtx = tempCanvas.getContext('2d');
  tCtx.putImageData(imgData, 0, 0);

  outCtx.save();
  if (effectMode.value === 'remove') {
    outCtx.globalCompositeOperation = 'destination-in';
  } else {
    outCtx.globalAlpha = 0.7;
  }
  outCtx.drawImage(tempCanvas, 0, 0, outCanvas.width, outCanvas.height);
  outCtx.restore();
}

function finishProcessing() {
  processing = false;
  setStatus('Processing complete.');
  recorder.stop();
  playBtn.disabled = false;
  pauseBtn.disabled = false;
  downloadBtn.disabled = false;
  processBtn.disabled = false;
}
</script>
</body>
</html>