<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Video Layer Studio</title>
<style>
  body {
    background: #0d1117;
    color: #c9d1d9;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1em;
  }
  h1 {
    color: #58a6ff;
    margin-bottom: 1em;
  }
  video, canvas {
    width: 100%;
    max-width: 720px;
    border-radius: 12px;
    display: block;
    margin-bottom: 1em;
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  #videoWrapper {
    position: relative;
    display: inline-block;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 1em;
  }
  button, select {
    background: #238636;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    cursor: pointer;
    font-weight: bold;
  }
  button:hover { background: #2ea043; }
  #status { margin-top: 1em; color: #8b949e; font-size: 0.9rem; text-align: center; }
  #progressBar {
    width: 100%;
    max-width: 720px;
    height: 10px;
    background: #21262d;
    border-radius: 5px;
    margin: 0.5em 0 1em;
    overflow: hidden;
  }
  #progressFill {
    height: 100%;
    width: 0%;
    background: #58a6ff;
    transition: width 0.2s linear;
  }
</style>
</head>
<body>

<h1>Video Layer Studio</h1>

<input type="file" id="videoInput" accept="video/*">

<div id="videoWrapper">
  <video id="video" playsinline controls></video>
  <canvas id="canvas"></canvas>
</div>

<div class="controls">
  <select id="effectSelect">
    <option value="person">Keep Foreground Only</option>
    <option value="blur">Blur Background</option>
    <option value="color">Replace Background Color</option>
    <option value="transparent">Transparent Background</option>
  </select>
  <button id="processBtn" disabled>Process</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="progressBar"><div id="progressFill"></div></div>
<div id="status">Select a video to start.</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const input = document.getElementById('videoInput');
const processBtn = document.getElementById('processBtn');
const resetBtn = document.getElementById('resetBtn');
const effectSelect = document.getElementById('effectSelect');
const progressBar = document.getElementById('progressFill');
const status = document.getElementById('status');

let seg;
let currentMask = null;
let isProcessing = false;

// --- Load video ---
input.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  video.src = URL.createObjectURL(file);
  video.load();
  video.onloadeddata = () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    processBtn.disabled = false;
    status.textContent = `Loaded video (${video.videoWidth}x${video.videoHeight})`;
    video.play().catch(() => {});
  };
});

// --- Initialize segmentation model ---
seg = new SelfieSegmentation({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`
});
seg.setOptions({ modelSelection: 1 }); // Use best-quality model
seg.onResults(results => {
  currentMask = results.segmentationMask;
  drawFrame();
});

// --- Draw frame with chosen effect ---
function drawFrame() {
  if (!currentMask) return;

  const effect = effectSelect.value;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Composite the mask according to selected effect
  ctx.save();
  switch (effect) {
    case 'person':
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(currentMask, 0, 0, canvas.width, canvas.height);
      break;

    case 'blur':
      // Draw background blurred
      const blurCanvas = document.createElement('canvas');
      blurCanvas.width = canvas.width;
      blurCanvas.height = canvas.height;
      const bctx = blurCanvas.getContext('2d');
      bctx.filter = 'blur(12px)';
      bctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(currentMask, 0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'destination-over';
      ctx.drawImage(blurCanvas, 0, 0);
      break;

    case 'color':
      ctx.globalCompositeOperation = 'destination-over';
      ctx.fillStyle = '#004466';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(currentMask, 0, 0, canvas.width, canvas.height);
      break;

    case 'transparent':
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(currentMask, 0, 0, canvas.width, canvas.height);
      break;
  }
  ctx.restore();
}

// --- Process video live ---
processBtn.onclick = async () => {
  if (isProcessing) return;
  isProcessing = true;
  processBtn.disabled = true;
  progressBar.style.width = '0%';
  status.textContent = 'Processing...';

  const duration = video.duration;
  const fps = 25;
  const totalFrames = Math.floor(duration * fps);
  video.currentTime = 0;

  for (let i = 0; i < totalFrames; i++) {
    await new Promise(r => {
      video.onseeked = r;
      video.currentTime = i / fps;
    });

    await seg.send({ image: video });

    progressBar.style.width = ((i / totalFrames) * 100).toFixed(1) + '%';
  }

  status.textContent = 'Processing complete (live render only).';
  isProcessing = false;
};

// --- Reset ---
resetBtn.onclick = () => {
  video.pause();
  video.src = '';
  currentMask = null;
  progressBar.style.width = '0%';
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  status.textContent = 'Select a video to start.';
  processBtn.disabled = true;
};
</script>

</body>
</html>
