<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Video Background Remover</title>
<style>
body {
  background: #0d1117;
  color: #c9d1d9;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2em;
}
h1 { color: #58a6ff; margin-bottom: 1em; text-align: center; }
#controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 1em; margin-bottom: 1em; }
button, input[type=file], select {
  background: #21262d; color: #c9d1d9; border: 1px solid #30363d;
  padding: 0.5em 1em; border-radius: 8px; cursor: pointer;
}
video, canvas { width: 90%; max-width: 800px; border-radius: 10px; margin-top: 1em; border: 2px solid #30363d; }
#status { margin-top: 1em; font-size: 0.9rem; color: #8b949e; }
</style>
</head>
<body>

<h1>ðŸŽ¥ AI Background Remover</h1>

<div id="controls">
  <input type="file" id="videoInput" accept="video/*">
  <select id="modeSelect">
    <option value="motion">Motion</option>
    <option value="all">Edges</option>
    <option value="threshold">Threshold</option>
  </select>
  <button id="startBtn">Start Processing</button>
  <button id="stopBtn">Stop</button>
  <button id="saveBtn">Download Result</button>
</div>

<video id="outputVideo" controls></video>
<canvas id="processCanvas" style="display:none;"></canvas>
<div id="status">Status: Waiting for video...</div>

<script>
const videoInput = document.getElementById("videoInput");
const modeSelect = document.getElementById("modeSelect");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const saveBtn = document.getElementById("saveBtn");
const status = document.getElementById("status");

const outputVideo = document.getElementById("outputVideo");
const processCanvas = document.getElementById("processCanvas");
const ctx = processCanvas.getContext("2d");

let video = document.createElement("video");
video.muted = true;

let worker = new Worker("detector-worker.js");
let pendingProcess = null;
let processing = false;
let recorder = null;
let recordedBlobs = [];

// --- Video load ---
videoInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  video.src = URL.createObjectURL(file);
  video.load();
  video.onloadeddata = () => {
    processCanvas.width = video.videoWidth;
    processCanvas.height = video.videoHeight;
    outputVideo.width = video.videoWidth;
    outputVideo.height = video.videoHeight;
    status.textContent = `Loaded video: ${file.name} (${video.videoWidth}x${video.videoHeight})`;
    startBtn.disabled = false;
  };
});

// --- Start processing ---
startBtn.addEventListener("click", async () => {
  if (!video.src) { alert("Select a video first"); return; }

  startBtn.disabled = true;
  stopBtn.disabled = false;
  saveBtn.disabled = true;
  processing = true;
  recordedBlobs = [];

  // Initialize MediaRecorder for final output
  const stream = processCanvas.captureStream(30);
  recorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp8" });
  recorder.ondataavailable = ev => { if(ev.data && ev.data.size) recordedBlobs.push(ev.data); };
  recorder.start(1000);

  video.currentTime = 0;
  await video.play().catch(()=>{});
  status.textContent = "Processing started...";
  processLoop();
});

// --- Stop processing ---
stopBtn.addEventListener("click", () => {
  processing = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  saveBtn.disabled = recordedBlobs.length === 0;
  if(recorder && recorder.state === "recording") recorder.stop();
  status.textContent = "Processing stopped.";
});

// --- Download result ---
saveBtn.addEventListener("click", () => {
  if (recordedBlobs.length === 0) return alert("No video recorded.");
  const blob = new Blob(recordedBlobs, { type:"video/webm" });
  const url = URL.createObjectURL(blob);
  outputVideo.src = url;
  outputVideo.play();
  const a = document.createElement("a");
  a.href = url;
  a.download = `processed_${Date.now()}.webm`;
  a.click();
  status.textContent = "Video saved!";
});

// --- Frame processing loop ---
function processLoop() {
  if (!processing) return;
  if(video.paused || video.ended){
    requestAnimationFrame(processLoop);
    return;
  }

  ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
  const frame = ctx.getImageData(0, 0, processCanvas.width, processCanvas.height);

  if(!pendingProcess){
    pendingProcess = new Promise(resolve => {
      worker.onmessage = e => {
        if(e.data.type==="mask"){
          const mask = new ImageData(new Uint8ClampedArray(e.data.maskData), e.data.width, e.data.height);
          // apply mask to canvas (background removal)
          ctx.putImageData(mask, 0, 0);
        }
        pendingProcess = null;
        resolve();
      };
      worker.postMessage({ type:"process", frame, mode: modeSelect.value });
    });
  }

  requestAnimationFrame(processLoop);
}
</script>

</body>
</html>